---
id: cqrs
title: "ü§† CQRS"
---

- [Introduction](#introduction)
- [Installation](#installation)
- [Utilisation des commandes (Command)](#utilisation-des-commandes-command)
  - [√âtape 1 : Cr√©er une commande](#√©tape-1--cr√©er-une-commande)
  - [√âtape 2 : Cr√©er un handler pour la commande](#√©tape-2--cr√©er-un-handler-pour-la-commande)
  - [√âtape 3 : Enregistrer la commande et son handler](#√©tape-3--enregistrer-la-commande-et-son-handler)
  - [√âtape 4 : Ex√©cuter la commande dans un contr√¥leur](#√©tape-4--ex√©cuter-la-commande-dans-un-contr√¥leur)
- [Utilisation des requ√™tes (Query)](#utilisation-des-requ√™tes-query)
  - [√âtape 1 : Cr√©er une requ√™te](#√©tape-1--cr√©er-une-requ√™te)
  - [√âtape 2 : Cr√©er un handler pour la requ√™te](#√©tape-2--cr√©er-un-handler-pour-la-requ√™te)
  - [√âtape 3 : Enregistrer la requ√™te et son handler](#√©tape-3--enregistrer-la-requ√™te-et-son-handler)
  - [√âtape 4 : Ex√©cuter la requ√™te dans un contr√¥leur](#√©tape-4--ex√©cuter-la-requ√™te-dans-un-contr√¥leur)

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

## Introduction

**CQRS** (*Command Query Responsibility Segregation*) est un mod√®le d'architecture qui s√©pare les responsabilit√©s des commandes et des requ√™tes. L'id√©e principale est d'utiliser un mod√®le diff√©rent pour les op√©rations d'√©criture (commandes) et de lecture (requ√™tes). Cette approche peut √™tre utile dans des situations complexes, bien que pour la plupart des syst√®mes, **CQRS** puisse introduire une certaine complexit√© suppl√©mentaire.

[Pour plus d'informations sur CQRS, consultez cet article](https://www.martinfowler.com/bliki/CQRS.html).

## Installation

Ajoutez le package CQRS √† votre projet avec la commande suivante :

```bash
composer require bowphp/cqrs
```

## Utilisation des commandes (Command)

Les commandes sont utilis√©es pour effectuer des op√©rations d'√©criture ou des actions qui modifient l'√©tat de votre syst√®me.

### √âtape 1 : Cr√©er une commande

Cr√©ez une commande en impl√©mentant l'interface `Bow\CQRS\Command\CommandInterface`. Par exemple, pour cr√©er un utilisateur :

```php title="app/Commands/CreateUserCommand.php"
use Bow\CQRS\Command\CommandInterface;

class CreateUserCommand implements CommandInterface
{
    public function __construct(
        public string $username,
        public string $email
    ) {}
}
```

### √âtape 2 : Cr√©er un handler pour la commande

Cr√©ez un handler qui ex√©cutera la logique associ√©e √† la commande. Ce handler doit impl√©menter l'interface `Bow\CQRS\Command\CommandHandlerInterface` :

```php {7} title="app/CommandHandlers/CreateUserCommandHandler.php"
use Bow\CQRS\Command\CommandHandlerInterface;

class CreateUserCommandHandler implements CommandHandlerInterface
{
    public function __construct(public UserService $userService) {}

    public function process(CommandInterface $command): mixed
    {
        if ($this->userService->exists($command->email)) {
            throw new UserServiceException(
                "The user already exists"
            );
        }

        return $this->userService->create([
            "username" => $command->username,
            "email" => $command->email
        ]);
    }
}
```

### √âtape 3 : Enregistrer la commande et son handler

Ajoutez la commande et son handler dans le registre des commandes dans `App\Configurations\ApplicationConfiguration::class` :

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
    CQRSRegistration::commands([
        CreateUserCommand::class => CreateUserCommandHandler::class
    ]);
}
```

### √âtape 4 : Ex√©cuter la commande dans un contr√¥leur

Dans un contr√¥leur, utilisez le `CommandBus` pour ex√©cuter la commande :

```php {3,9,15-18,20} title="app/Controllers/UserController.php"
namespace App\Controllers;

use Bow\CQRS\Command\CommandBus;
use App\Controllers\Controller;
use App\Commands\CreateUserCommand;

class UserController extends Controller
{
    public function __construct(private CommandBus $commandBus) {}

    public function __invoke(Request $request)
    {
        $payload = $request->only(['username', 'email']);

        $command = new CreateUserCommand(
            $payload['username'],
            $payload['email']
        );

        $result = $this->commandBus->execute($command);

        return redirect()
            ->back()
            ->withFlash("message", "User created");
    }
}
```

Ajoutez une route pour appeler cette m√©thode :

```php
$app->post("/users/create", UserController::class);
```

## Utilisation des requ√™tes (Query)

Les requ√™tes sont utilis√©es pour r√©cup√©rer des donn√©es sans modifier l'√©tat de votre syst√®me.

### √âtape 1 : Cr√©er une requ√™te

Cr√©ez une requ√™te en impl√©mentant l'interface `Bow\CQRS\Query\QueryInterface`. Par exemple, pour r√©cup√©rer un utilisateur par son ID :

```php title="app/Queries/GetUserByIdQuery.php"
use Bow\CQRS\Query\QueryInterface;

class GetUserByIdQuery implements QueryInterface
{
    public function __construct(public int $userId) {}
}
```

### √âtape 2 : Cr√©er un handler pour la requ√™te

Cr√©ez un handler pour ex√©cuter la logique de r√©cup√©ration des donn√©es. Ce handler doit impl√©menter l'interface `Bow\CQRS\Query\QueryHandlerInterface` :

```php {7} title="app/QueryHandlers/GetUserByIdQueryHandler.php"
use Bow\CQRS\Query\QueryHandlerInterface;

class GetUserByIdQueryHandler implements QueryHandlerInterface
{
    public function __construct(public UserService $userService) {}

    public function process(QueryInterface $query): mixed
    {
        return $this->userService->findById($query->userId);
    }
}
```

### √âtape 3 : Enregistrer la requ√™te et son handler

Ajoutez la requ√™te et son handler dans le registre des requ√™tes dans `App\Configurations\ApplicationConfiguration::class` :

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
    CQRSRegistration::queries([
        GetUserByIdQuery::class => GetUserByIdQueryHandler::class
    ]);
}
```

### √âtape 4 : Ex√©cuter la requ√™te dans un contr√¥leur

Dans un contr√¥leur, utilisez le `QueryBus` pour ex√©cuter la requ√™te :

```php {3,9,15-18,20} title="app/Controllers/UserController.php"
namespace App\Controllers;

use Bow\CQRS\Query\QueryBus;
use App\Controllers\Controller;
use App\Queries\GetUserByIdQuery;

class UserController extends Controller
{
    public function __construct(private QueryBus $queryBus) {}

    public function show(int $userId)
    {
        $query = new GetUserByIdQuery($userId);

        $user = $this->queryBus->execute($query);

        return view("user.profile", ["user" => $user]);
    }
}
```

Ajoutez une route pour appeler cette m√©thode :

```php
$app->get("/users/{id}", [UserController::class, 'show']);
```

Avec **CQRS**, vous pouvez structurer vos applications pour s√©parer clairement les pr√©occupations entre la lecture et l'√©criture, tout en conservant un code organis√© et maintenable.


<SuggestionFeature />
