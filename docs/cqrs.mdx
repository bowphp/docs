---
id: cqrs
title: "ðŸ¤  CQRS"
---

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

**CQRS** (*sÃ©grÃ©gation des responsabilitÃ©s des requÃªtes de commande*).

Au cÅ“ur se trouve l'idÃ©e selon laquelle vous pouvez utiliser un modÃ¨le diffÃ©rent pour mettre Ã  jour les informations que celui que vous utilisez pour lire les informations.
Dans certaines situations, cette sÃ©paration peut Ãªtre utile, mais sachez que pour la plupart des systÃ¨mes, **CQRS** ajoute une complexitÃ© risquÃ©e.

[Pour plus d'information](https://www.martinfowler.com/bliki/CQRS.html)

## Install

Installez le package suivant: 

```bash
composer require bowphp/cqrs
```

## Utilisation

Tout d'abord, crÃ©ez l'exemple de commande qui implement l'interface `Bow\CQRS\Command\CommandInterface`. Pour cette exemple, nous allons crÃ©er notre commande de la dossier `app/Commands`.
Cette commande sera chargÃ© de la crÃ©ation d'un utilisateur:

```php title="app/Commands/CreateUserCommand.php"
use Bow\CQRS\Command\CommandInterface;

class CreateUserCommand implements CommandInterface
{
  public function __construct(
    public string $username,
    public string $email
  ) {}
}
```

Ensuite, nous allons crÃ©er le handler qui va Ã©coutÃ© et executÃ© les instructions lorsque la commande `CreateUserCommand` est lancÃ©. Cette classe doit implementer l'interface `Bow\CQRS\Command\CommandHandlerInterface` :

```php {7} title="app/CommandHandlers/CreateUserCommandHandler.php"
use Bow\CQRS\Command\CommandHandlerInterface;

class CreateUserCommandHandler implements CommandHandlerInterface
{
  public function __construct(public UserService $userService) {}

  public function process(CommandInterface $command): mixed
  {
    if ($this->userService->exists($command->email)) {
      throw new UserServiceException(
        "The user already exists"
      );
    }

    return $this->userService->create([
      "username" => $command->username,
      "email" => $command->email
    ]);
  }
}
```

:::info
C'est `process` qui va executer les instructions. Elle va recevoir l'instance de la commande qui a Ã©tÃ© crÃ©Ã©
:::

## Registration

Pour terminer, nous allons ajouter la commande au registre dans `App\Configurations\ApplicationConfiguration::class`:

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
  CQRSRegistration::commands([
    CreateUserCommand::class => CreateUserCommandHandler::class
  ]);
}
```

:::note
Ici nous disons que lorsque la commande `CreateUserCommand` est executÃ© dÃ©clanche le handler `CreateUserCommandHandler`
:::

### ExÃ©cute la commande

ExÃ©cuter la commande dans le contrÃ´leur; donc pour l'exemple nous avons crÃ©Ã© un controller `UserController`:

```php {3,9,15-18,20} title="app/Controllers/UserController.php"
namespace App\Controllers;

use Bow\CQRS\Command\CommandBus;
use App\Controllers\Controller;
use App\Commands\CreateUserCommand;

class UserController extends Controller
{
  public function __construct(private CommandBus $commandBus) {}

  public function __invoke(Request $request)
  {
    $payload = $request->only(['username', 'email']);

    $command = new CreateUserCommand(
      $payload['username'],
      $payload['email']
    );

    $result = $this->commandBus->execute($command);

    return redirect()
      ->back()
      ->withFlash("message", "User created");
  }
}
```

- Injection de `CommandBus` dans le controller
- Nous crÃ©ons une instance de `CreateUserCommand` aprÃ¨s validation du formulaire
- Nous lanÃ§ons la methode sur la `$this->commandBus->execute` 

#### Mettre un nouvel itinÃ©raire :

```php
$app->post("/users/create", UserController::class);
```

<SuggestionFeature />
