---
id: database
title: "ðŸŽ¯ DÃ©marrage"
---

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

## Introduction

Bow rend l'interaction avec les bases de donnÃ©es extrÃªmement simple sur deux backends de bases de donnÃ©es en utilisant le `SQL brut`, le gÃ©nÃ©rateur de requÃªtes courant et l'[ORM](./orm) Barry.

Actuellement, Bow prend en charge deux bases de donnÃ©es:

- MySQL
- PostgreSQL
- SQLite

## Configuration

La configuration de la base donnÃ©e de votre application se localise dans le fichier `config/database.php`. Dans ce fichier, vous pouvez dÃ©finir tous les connections de votre base de donnÃ©e et un exemple en plus pour tous les supports de base de donnÃ©e est defini dans ce fichier.

## SQLite Configuration

AprÃ¨s avoir crÃ©Ã© une nouvelle base de donnÃ©es SQLite Ã  l'aide d'une commande tel que `touch var/database.sqlite`, vous pouvez facilement configurer vos variables d'environnement (dans le fichier `.env.json`) pour qu'elles pointent vers cette base de donnÃ©es nouvellement crÃ©Ã©e Ã  l'aide du chemin absolu de la base de donnÃ©es:

```json
{
  "DB_DEFAULT": "sqlite",
  "SQLITE_DATABASE": "/absolute/path/to/database.sqlite",
}
```

## Connexion Ã  plusieurs Bases de donnÃ©e

Lorsque vous utilisez plusieurs connexions, vous pouvez accÃ©der Ã  chaque connexion via la mÃ©thode static de `connexion` sur la classe [Bow\Database\Database::class](https://bowphp.com/api/master/Bow/Database/Database.html). Le nom transmis Ã  la mÃ©thode de connexion doit correspondre Ã  l'une des points de connexions rÃ©pertoriÃ©es dans votre fichier de configuration `config/database.php`:

```php
use Bow\Database\Database;

$users = Database::connection('sqlite')->select(...);
```

Ou via le helper `db`:

```php
$users = db('sqlite')->select(...);
```

Une fois la configuration changÃ©, elle est directement appliquer sur la connexion des modÃ¨les. [Cliquer ici](./orm) pour plus d'information sur les models.

## Utilisation de requÃªte SQL Brute

Les requÃªte brute ici sont les requÃªtes SQL Ã©crite littÃ©ralement sans passer par un Query Builder.
Dans cette section nous allons utiliser une table nommer `pets` pour effectuer nos requÃªte avec.

Voici la description de la table `pets`:

```sql
CREATE TABLE `pets` (
  id int primary key,
  name varchar(200),
  color varchar(50)
);
```

Alors notre table Ã  comme colonne:

| Nom de la colonne | Description |
| ----------------- | ----------- |
| `id`   | Ici la clÃ© primaire |
| `name` | Le nom du pet |
| `color`| La couleur du pet |

> Pour information, un `pet` c'est un animal domestique ðŸ˜…

### Execution de requÃªte Select

Pour exÃ©cuter une requÃªte brute de type `SELECT` nous devrez utiliser la mÃ©thode `Database::select` ou le helper `db_select`. On considÃ¨re notre table `pets` et que nous sommes bien connectÃ©s Ã  la base de donnÃ©e.

Execution d'une requÃªte pour obtenir toutes les informations de la table `pets`:

```php
use Bow\Database\Database;

$pets = Database::select('select * from `pets`');
```

Via helper `db_select`:

```php
$pets = db_select('select * from `pets`');
```

### SÃ©lection conditionnelle

Execution d'une requÃªte pour obtenir toutes les informations de la table `pets` quand `id` Ã©gale Ã  1:

```php
use Bow\Database\Database;

$pet = Database::select('select * from `pets` where id = :id', ['id' => 1]);
```

Via helper `db_select`:

```php
$pet = db_select('select * from `pets` where id = :id', ['id' => 1]);
```

Notez que la valeur retournÃ©e par la mÃ©thode `db_select` est un `array` ou `null` s'il n'y a aucune informations.
Dans le cas ou c'est un `array` le contenu est de type `stClass` (plus d'information sur [stClass](http://php.net/manual/fr/language.types.object.php)).

### Execution de requÃªte Insert

Pour exÃ©cuter une requÃªte brute de type `INSERT` nous devrez utiliser la mÃ©thode `Database::insert` ou le helper `db_insert`. On considÃ¨re toujours notre table `pets` et que nous sommes bien connectÃ©s Ã  la base de donnÃ©e.

Execution d'une requÃªte pour insÃ©rer une information dans la table `pets`:

```php
use Bow\Database\Database;

$pet = [
  'id' => 1,
  'name' => 'Medor',
  'color' => 'Green'
];

$inserted = Database::insert('insert into `pets` (id, name, color) values (:id, :name, :color);', $pet);
```

Via helper `db_insert`:

```php
$pet = [
  'id' => 2,
  'name' => 'Mashmalo',
  'color' => 'White'
];

$inserted = db_insert('insert into `pets` (id, name, color) values (:id, :name, :color);', $pet);
```

Notez que la valeur retournÃ©e par la fonction `db_insert` est un `int` ou `number` qui est le nombre d'insertion.

#### Insertion multiple

Vous avez aussi la possibilitÃ© d'insÃ©rer plusieurs enregistrements en mÃªme temps.

```php
use Bow\Database\Database;

// Liste de pets
$pets = [
  [
    'id' => 1,
    'name' => 'Medor',
    'color' => 'Black'
  ],
  [
    'id' => 2,
    'name' => 'Milou',
    'color' => 'Gay'
  ]
];

$inserted = Database::insert(
  'insert into `pets` (id, name, color) values (:id, :name, :color);',
  $pets
);
```

Via helper `db_insert`:

```php
$updated = db_insert(
  'insert into `pets` (id, name, color) values (:id, :name, :color);',
  $pets
);
```

### Execution de requÃªte Update

Pour exÃ©cuter une requÃªte brute de type `UPDATE` nous devrez utiliser la mÃ©thode `Database::update` ou le helper `db_update`. On considÃ¨re toujours notre table `pets` et que nous sommes bien connectÃ©s Ã  la base de donnÃ©e.

Execution d'une requÃªte de mettre Ã  jour d'information dans la table `pets`:

```php
use Bow\Database\Database;

$pet = [
  'id' => 1,
  'name' => 'Medora',
  'color' => 'Purple'
];

$updated = Database::update(
  'update `pets` set id = :id, name = :name, color = :color where id = :id',
  $pet
);
```

Via le helper `db_update`:

```php
$pet = [
  'id' => 2,
  'name' => 'Spark',
  'color' => 'Yellow'
];

$updated = db_update(
  'update `pets` set id = :id, name = :name, color = :color where id = :id',
  $pet
);
```

### Execution de requÃªte Delete

Pour exÃ©cuter une requÃªte brute de type `DELETE` nous devrez utiliser la mÃ©thode `Database::delete` ou le helper `db_delete`. On considÃ¨re toujours notre table `pets` et que nous sommes bien connectÃ©s Ã  la base de donnÃ©e.

Execution d'une requÃªte pour insÃ©rer une information dans la table `pets`:

```php
use Bow\Database\Database;

$deleted = Database::delete(
  'delete from `pets` where id = :id',
  ['id' => 1]
);
```

Via le helper `db_delete`:

```php
$deleted = db_delete(
  'delete from `pets` where id = :id',
  ['id' => 2]
);
```

### Execution de requÃªte

Pour exÃ©cuter une requÃªte brute autre que `SELECT`, `UPDATE`, `INSERT`, `DELETE`. Il y a une mÃ©thode faite pour `Database::statement` ou le helper `db_statement`.

```php
use Bow\Database\Database;

Database::statement('alter table `pets` add `owner` varchar(80) default null;');
```

Via le helper `db_statement`:

```php
db_statement('alter table `pets` add `owner` varchar(80) default null;');
```

## Database Transactions

Vous pouvez utiliser la mÃ©thode de `startTransaction` sur la classe `Database` pour exÃ©cuter un ensemble d'opÃ©rations dans une transaction de base de donnÃ©es.

Si vous passez une `Closure` et qu'une exception est levÃ©e dans la fonction de rappel de la transaction, la transaction sera automatiquement annulÃ©e. Si la `Closure` s'exÃ©cute correctement, la transaction sera automatiquement validÃ©e. Vous n'avez pas Ã  vous soucier de l'annulation manuelle ou de la validation lorsque vous utilisez la mÃ©thode de transaction:

```php
use Bow\Database\Database;

Database::startTransaction(function () {
  Database::update('update users set votes = :votes', ['votes' => 1]);

  Database::delete('delete from posts');
});
```

Via le helper `db_transaction`:

```php
db_transaction(function () {
  update('update users set votes = :votes', ['votes' => 1]);

  delete('delete from posts');
});
```

### Utilisation manuelle de la transaction

Vous pouvez aussi utiliser manuellement le systÃ¨me de transaction.
Pour dÃ©marrer la transaction avec la mÃ©thode :

```php
use Bow\Database\Database;

Database::startTransaction();
// Ou
db_transaction();
```

Vous pouvez annuler la transaction avec la mÃ©thode:

```php
use Bow\Database\Database;

Database::rollback();
// Ou
db_rollback();
```

Vous pouvez valider la transaction avec la mÃ©thode:

```php
use Bow\Database\Database;

Database::commit();
// Ou
db_commit();
```

Avec la mÃ©thode `inTransaction` vous pouvez vÃ©rifier si la base de donnÃ©e est en transaction:

```php
use Bow\Database\Database;

Database::inTransaction();
// Ou
db_transaction_started();
```

## Les jointures

ConsidÃ©rons les tables suivantes :

```sql
create table `authors` (
  `id` int primary key,
  `name` varchar(200)
);

create table `pets` (
  `id` int primary key,
  `name` varchar(200),
  `color` varchar(50),
  `author_id` int default 0
);
```

Pour faire une jointure dans Bow Framework c'est trÃ¨s simple en fait. Pour ce faire on utilise la mÃ©thode `join`.

```php
$results = db_table('pets')->join('authors', 'authors.id', 'pets.author_id')->get();
```

Souvent, il est intÃ©ressant d'ajouter des contraintes dans la requÃªte normalement avec la clause `WHERE`.

```php
$results = db_table('pets')
  ->join('authors', 'authors.id', 'pets.author_id')
  ->whereRaw('pets.author_id', 1)->get();
```

Normalement, vous pouvez ajouter plusieurs jointures dans l'appel de mÃ©thode.
Pour l'exemple disons qu'il y a une autre table nommÃ©e `countries` qui est le pays du propriÃ©taire et que la table `authors` est maintenant :

```sql
create table `authors` (
  `id` int primary key,
  `name` varchar(200),
  `country_id` int
);
```

Notre requÃªte sera maintenant :

```php
$results = db_table('authors')
  ->join('authors', 'authors.id', 'pets.author_id')
  ->join('countries', 'countries.id', 'pets.country_id')
  ->whereRaw('pets.author_id', 1)
  ->get();
```

:::note
Vous pouvez consulter l'API de la classe [Database](./api/5.x/Bow/Database/Database.html) pour plus d'information.
:::

<SuggestionFeature />
