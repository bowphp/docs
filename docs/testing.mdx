---
id: testing
title: "üõ´ Testez votre application"
---

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

## Introduction

:::info
L'API de test fonctionnel de Bow Framework permet de tester vos API de mani√®re fluide en utilisant des requ√™tes HTTP. Cette API est construite autour de PHPUnit, ce qui vous permet d'utiliser toute la puissance de ce framework pour effectuer des tests. Les principales op√©rations HTTP (GET, POST, PUT, DELETE, PATCH) sont couvertes, et il est possible d'ajouter des en-t√™tes ou des pi√®ces jointes √† vos requ√™tes.
:::

### Classe `TestCase`

La classe principale pour utiliser l'API de test est `TestCase`, qui √©tend la classe `PHPUnitTestCase` de PHPUnit. Elle fournit une interface simple pour envoyer des requ√™tes HTTP et v√©rifier les r√©ponses.

### **M√©thodes de la classe `TestCase`**

:::tip Configuration
Le `base_url` des appels HTTP est la valeur `APP_URL`, mais vous pouvez aussi la sp√©cifier manuellement avec la propri√©t√© `url` dans la classe du test unitaire.
:::

#### **1. `attach(array $attach)`**
Permet d'ajouter des pi√®ces jointes (fichiers ou donn√©es) √† vos requ√™tes.

**Exemple d'utilisation** :

```php
$test->attach([
  'file' => new \CURLFile('/path/to/file.jpg')
]);
```

#### **2. `withHeaders(array $headers)`**
Permet de sp√©cifier des en-t√™tes suppl√©mentaires pour toutes les requ√™tes suivantes.

```php
$test->withHeaders([
  'Authorization' => 'Bearer token',
  'Content-Type' => 'application/json'
]);
```

#### **3. `withHeader(string $key, string $value)`**
Ajoute un en-t√™te unique √† vos requ√™tes.

```php
$test->withHeader('X-Custom-Header', 'custom_value');
```

#### **4. `get(string $url, array $param = [])`**
Effectue une requ√™te GET. Vous pouvez ajouter des param√®tres suppl√©mentaires √† la requ√™te.

```php
$response = $test->get('/api/users', ['page' => 1]);
```

#### **5. `post(string $url, array $param = [])`**
Effectue une requ√™te POST. Vous pouvez ajouter des donn√©es et des fichiers en utilisant la m√©thode `attach()`.

```php
$response = $test->post('/api/users', ['name' => 'John Doe']);
```

#### **6. `put(string $url, array $param = [])`**
Effectue une requ√™te PUT.

```php
$response = $test->put('/api/users/1', ['name' => 'John Updated']);
```

#### **7. `delete(string $url, array $param = [])`**
Effectue une requ√™te DELETE. Cette m√©thode utilise `PUT` en interne avec le param√®tre `_method` pour simuler une requ√™te DELETE.

```php
$response = $test->delete('/api/users/1');
```

#### **8. `patch(string $url, array $param = [])`**
Effectue une requ√™te PATCH. Comme pour `delete()`, cette m√©thode utilise `PUT` en interne.

```php
$response = $test->patch('/api/users/1', ['name' => 'John Modified']);
```

#### **9. `visit(string $method, string $url, array $params = [])`**
Effectue une requ√™te HTTP g√©n√©rique en fonction de la m√©thode sp√©cifi√©e (`get`, `post`, `put`, etc.).

```php
$response = $test->visit('get', '/api/users');
```

### **Exemple complet d'utilisation**

Voici un exemple complet qui montre comment configurer un test fonctionnel avec l'API de test :

```php
use Bow\Testing\TestCase;

class UserApiTest extends TestCase
{
  protected ?string $url = 'http://localhost:8080';

  public function testCreateUser()
  {
    // Ajouter un en-t√™te d'autorisation
    $this->withHeader('Authorization', 'Bearer token');

    // Ajouter des donn√©es de test √† envoyer dans la requ√™te POST
    $data = [
      'name' => 'John Doe',
      'email' => 'john.doe@example.com'
    ];

    // Effectuer la requ√™te POST
    $response = $this->post('/api/users', $data);

    // V√©rifier que la r√©ponse a le statut HTTP 201
    $response->assertStatus(201);
    $result = $response->toArray();

    // V√©rifier que le nom de l'utilisateur cr√©√© est correct
    $this->assertEquals('John Doe', $result['name']);
  }

  public function testGetUser()
  {
    // Faire une requ√™te GET pour r√©cup√©rer un utilisateur
    $response = $this->get('/api/users/1');

    // V√©rifier que la r√©ponse a le statut HTTP 200
    $response->assertStatus(200);
    $result = $response->toArray();

    // V√©rifier que l'ID de l'utilisateur est correct
    $this->assertEquals(1, $result['id']);
  }
}
```

## **Classe `Response` pour les tests fonctionnels**

:::info
La classe `Response` permet de manipuler les r√©ponses HTTP dans le cadre de tests fonctionnels avec Bow Framework. Elle encapsule un objet de la classe `HttpClientResponse` et expose plusieurs m√©thodes pour effectuer des assertions sur la r√©ponse.
:::

### **M√©thodes de la classe `Response`**

#### **1. `assertJson(string $message = ''): Response`**
V√©rifie que le contenu de la r√©ponse est au format JSON. Si ce n'est pas le cas, un √©chec de test sera g√©n√©r√©.

```php
$response->assertJson("La r√©ponse devrait √™tre au format JSON");
```

#### **2. `assertExactJson(array $data, string $message = ''): Response`**
V√©rifie que le contenu JSON de la r√©ponse correspond exactement aux donn√©es sp√©cifi√©es.

```php
$response->assertExactJson([
  'name' => 'John Doe',
  'email' => 'john.doe@example.com'
], "La r√©ponse JSON ne correspond pas aux donn√©es attendues.");
```

#### **3. `assertContainsExactText(string $data, string $message = ''): Response`**
V√©rifie que le contenu de la r√©ponse correspond exactement au texte donn√©.

```php
$response->assertContainsExactText("Bienvenue, John Doe", "Le texte de la r√©ponse ne correspond pas.");
```

#### **4. `assertHeader(string $header, string $message = ''): Response`**
V√©rifie qu'un en-t√™te sp√©cifique existe dans la r√©ponse.

```php
$response->assertHeader('Content-Type', "L'en-t√™te Content-Type est manquant.");
```

#### **5. `assertArray(string $message = ''): Response`**
V√©rifie que le contenu de la r√©ponse est un tableau.

```php
$response->assertArray("La r√©ponse devrait √™tre un tableau.");
```

#### **6. `assertContentType(string $content_type, string $message = ''): Response`**
V√©rifie que le type de contenu de la r√©ponse correspond √† celui sp√©cifi√©.

```php
$response->assertContentType('application/json', "Le type de contenu n'est pas 'application/json'.");
```

#### **7. `assertContentTypeJson(string $message = ''): Response`**
V√©rifie que le type de contenu est `application/json`.

```php
$response->assertContentTypeJson("Le type de contenu devrait √™tre JSON.");
```

#### **8. `assertContentTypeText(string $message = ''): Response`**
V√©rifie que le type de contenu est `text/plain`.

```php
$response->assertContentTypeText("Le type de contenu devrait √™tre text/plain.");
```

#### **9. `assertContentTypeHtml(string $message = ''): Response`**
V√©rifie que le type de contenu est `text/html`.

```php
$response->assertContentTypeHtml("Le type de contenu devrait √™tre text/html.");
```

#### **10. `assertContentTypeXml(string $message = ''): Response`**
V√©rifie que le type de contenu est `text/xml`.

```php
$response->assertContentTypeXml("Le type de contenu devrait √™tre text/xml.");
```

#### **11. `assertStatus(int $code, string $message = ''): Response`**
V√©rifie que le code de statut HTTP de la r√©ponse correspond √† celui sp√©cifi√©.

```php
$response->assertStatus(200, "Le statut HTTP n'est pas 200.");
```

#### **12. `assertKeyExists(string $key, string $message = ''): Response`**
V√©rifie qu'une cl√© existe dans le contenu JSON de la r√©ponse.

```php
$response->assertKeyExists('id', "La cl√© 'id' est manquante dans la r√©ponse.");
```

#### **13. `assertKeyMatchValue(string|int $key, mixed $value, string $message = ''): Response`**
V√©rifie qu'une cl√© sp√©cifique dans le contenu JSON de la r√©ponse correspond √† une valeur sp√©cifi√©e.

```php
$response->assertKeyMatchValue('name', 'John Doe', "Le nom dans la r√©ponse ne correspond pas.");
```

#### **14. `assertContains(string $text): Response`**
V√©rifie que le contenu de la r√©ponse contient une sous-cha√Æne sp√©cifique.

```php
$response->assertContains("Bienvenue", "Le texte 'Bienvenue' devrait √™tre pr√©sent.");
```

#### **15. `getContent(): string`**
R√©cup√®re le contenu brut de la r√©ponse.

```php
$content = $response->getContent();
```

#### **16. `toArray(): array|object`**
Retourne le contenu de la r√©ponse sous forme de tableau ou d'objet (si le contenu est JSON).

```php
$data = $response->toArray();
```

#### **17. `__call(string $method, array $params = [])`**
Permet d'appeler dynamiquement les m√©thodes de l'objet `HttpClientResponse` encapsul√© dans la r√©ponse.

```php
$response->getCode(); // Appelle getCode() sur HttpClientResponse
```

### **Exemple d'utilisation compl√®te**

Voici un exemple complet qui montre comment utiliser la classe `Response` pour tester une API :

```php
use Bow\Testing\TestCase;

class UserApiTest extends TestCase
{
  public function testCreateUser()
  {
    // Effectuer une requ√™te POST
    $data = [
      'name' => 'John Doe',
      'email' => 'john.doe@example.com'
    ];
    $response = $this->post('/api/users', $data);

    // V√©rifier que la r√©ponse a le statut 201
    $response->assertStatus(201, "Le statut HTTP devrait √™tre 201");

    // V√©rifier que le contenu est en JSON
    $response->assertJson("La r√©ponse devrait √™tre en JSON");

    // V√©rifier que le nom dans la r√©ponse est correct
    $response->assertKeyMatchValue('name', 'John Doe', "Le nom de l'utilisateur est incorrect.");
  }

  public function testGetUser()
  {
    // Effectuer une requ√™te GET
    $response = $this->get('/api/users/1');

    // V√©rifier que la r√©ponse a le statut 200
    $response->assertStatus(200, "Le statut HTTP devrait √™tre 200");

    // V√©rifier que l'utilisateur existe
    $response->assertKeyExists('id', "L'ID de l'utilisateur devrait exister.");
  }
}
```

## R√©f√©rences

:::tip Documentation compl√©mentaire
Consultez la [documentation officielle de PHPUnit](https://phpunit.de/) pour plus d'informations sur les assertions et les fonctionnalit√©s avanc√©es.
:::

<SuggestionFeature />
