---
id: controller
title: "ðŸ‘¨ðŸ½â€âœˆï¸ ContrÃ´leurs"
---

- [Introduction](#introduction)
- [Configuration](#configuration)
- [ContrÃ´leur basic](#contrÃ´leur-basic)
  - [DÃ©finir un contrÃ´leur](#dÃ©finir-un-contrÃ´leur)
  - [ContrÃ´leur et espaces de noms](#contrÃ´leur-et-espaces-de-noms)
  - [ContrÃ´leur et Middleware](#contrÃ´leur-et-middleware)
- [ContrÃ´leur REST](#contrÃ´leur-rest)
  - [DÃ©finir un contrÃ´leur rest](#dÃ©finir-un-contrÃ´leur-rest)
  - [Utilisons notre contrÃ´leur REST](#utilisons-notre-contrÃ´leur-rest)
    - [Prototype de la mÃ©thode `rest`](#prototype-de-la-mÃ©thode-rest)
    - [Utilisation simple](#utilisation-simple)
    - [Utilisation avec les contraintes](#utilisation-avec-les-contraintes)
    - [Utilisation via un tableau comme action](#utilisation-via-un-tableau-comme-action)
    - [Ignore des mÃ©thodes](#ignore-des-mÃ©thodes)
    - [Url et Action](#url-et-action)

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

## Introduction

Les contrÃ´leurs sont des moyens pour simplifier l'organisation de votre projet.

Au lieu de dÃ©finir toute la logique de gestion de la requÃªte en tant que `closure` dans les fichiers de routage, vous pouvez organiser ce comportement Ã  l'aide de classe de contrÃ´leur. Les contrÃ´leurs peuvent regrouper la logique de traitement des requÃªtes associÃ©e en une seule classe.

Les contrÃ´leurs sont stockÃ©s dans le rÃ©pertoire `app/Controllers`.

[![asciicast](https://asciinema.org/a/1r0hZPnP5wY5fCPcxNXtLTQ4r.svg)](https://asciinema.org/a/1r0hZPnP5wY5fCPcxNXtLTQ4r)

## Configuration

Vous avez la possibilitÃ© de modifier le `namespace` des contrÃ´leurs et des middlewares. Pour ce faire, ouvrez le fichier `app\Kernel.php`. La mÃ©thode `middlewares` permet Ã  Bow de savoir quel est le bon `namespace` Ã  ajouter sur le contrÃ´leur lors de l'execution de la rÃ©quÃªte ou lors de la gÃ©nÃ©ration de contrÃ´leur ou de middleware par le lanceur de tache `php bow`.

Imaginez que vous avez une application pour la gestion des Bus d'une Ã©cole et que vous voulez grouper tous vos contrÃ´leurs dans le `App\Bus\Controllers`. Alors comment faire Ã§a ?

Voici le code que cela pourrait donner :

```php
# Dans le fichier `app\Kernel.php`
public function namespaces()
{
  return [
    "controller" => "App\\Bus\\Controllers",
    ...
  ]
}
```

Ensuite, il faudra aussi changer un peu la configuration du lancer de tache:

```php
# Dans le fichier `bow`
$command = new Bow\Console\Command(__DIR__);
...
$command->setControllerDirectory(__DIR__.'/app/Bus/Controllers');
```

> Visitez ce [lien](./structure) pour plus d'information sur la personnalisation de la structure de l'application.

## ContrÃ´leur basic

### DÃ©finir un contrÃ´leur

Voici un exemple de classe de contrÃ´leur de base. Notez que le contrÃ´leur hÃ©rite de la classe `App\Controllers\Controller` de base. Cette classe de base fournit quelques mÃ©thodes pratiques telles que la mÃ©thode du `render`, qui peut Ãªtre utilisÃ©e pour compiler une vue.

```php
namespace App\Controllers;

use App\Controllers\Controller;
use App\Models\User;

class UserController extends Controller
{
  /**
   * Afficher le profil pour l'utilisateur donnÃ©.
   *
   * @param int $id
   * @return mixed
   */
  public function show($id)
  {
    return $this->render('user/profile', ['user' => User::findOrFail($id)]);
  }
}
```

Vous pouvez dÃ©finir une route dans le fichier `routes/app.php` vers cette action de contrÃ´leur comme suit:

```php
$app->get('user/:id', 'UserController::show');
```

DÃ©sormais, lorsqu'une demande correspond Ã  l'URI de la route spÃ©cifiÃ©e, la mÃ©thode `show` de la classe `UserController` sera exÃ©cutÃ©e. Bien entendu, les paramÃ¨tres de la route seront Ã©galement transmis Ã  la mÃ©thode.

Vous pouvez gÃ©nÃ©rer un contrÃ´leur en utilisant la commande `add:controller` de `php bow`:

```bash
php bow add:controller UserController
```

### ContrÃ´leur et espaces de noms

Il est trÃ¨s important de noter que nous nâ€™avons pas eu besoin de spÃ©cifier le `namespace` du contrÃ´leur complet lors de la dÃ©finition de la route du contrÃ´leur. Ã‰tant donnÃ© que `public/index.php` charge vos fichiers de route dans un groupe de routage contenant le `namespace`, nous avons uniquement spÃ©cifiÃ© la partie du nom de classe qui vient aprÃ¨s la partie `App\Controllers` de le `namespace`.

Si vous choisissez d'imbriquer vos contrÃ´leurs plus profondÃ©ment dans le rÃ©pertoire `App\Controllers`, utilisez le nom de classe spÃ©cifique relatif Ã  le `namespace` racine `App\Controllers`. Donc, si votre classe de contrÃ´leur complÃ¨te est `App\Controllers\Photo\AdminController`, vous devez enregistrer les routes sur le contrÃ´leur comme suit:

```php
$app->get('/foo', 'Photo\AdminController::action');
```

Vous pouvez gÃ©nÃ©rer un contrÃ´leur en utilisant la commande `add:controller` de `php bow`:

```bash
php bow add:controller Photo/AdminController
```

> Remarquez bien le nom du dossier, c'est en camel case. Le framework crÃ©era le namespace appropriÃ© pour la classe `AdminController` et qui sera `namepsace App\Controllers\Photo;`. Vous trouverez le controller dans un dossier `app/Controllers/Photo/AdminController`.

Plus d'information sur le [routing](./routing).

### ContrÃ´leur et Middleware

Les middlewares peuvent Ãªtre assigner Ã  la route du contrÃ´leur dans vos fichiers de route. Le middleware est stockÃ© dans le dossier `app\Middlewares`. Pour plus d'information sur les middlewares, visitez ce [lien](./middleware).

Exemple :

```php
$app->get('profile', 'UserController::show')->middleware('auth');
```

## ContrÃ´leur REST

Le contrÃ´leur REST sont un moyen simple pour mettre en place un API Rest. Cette approche, vous permet de, vous concentrez sur votre logique et laisser le Framework gÃ©rer le routage pour vous.

### DÃ©finir un contrÃ´leur rest

Pour dÃ©finir un nouveau contrÃ´leur Rest, nous devez utiliser le lancer de tache `php bow` avec la commande `generate:resource` dans votre console ou invite de commande :sunglasses:.

```bash
php bow generate:resource PetController
```

Un contrÃ´leur nommÃ© `PetController` sera donc crÃ©Ã©. Ce qui fait Ã§a particularitÃ© c'est qu'il y a dÃ©jÃ  des mÃ©thodes prÃ©dÃ©finir en lui et ces mÃ©thodes doivent rester telles quelles.

```php
namespace App\Controllers;

use App\Controllers\Controller;
use App\Models\Pet;

class PetController extends Controller
{
  /**
   * Point d'entrÃ©e
   *
   * @return void
   */
  public function index()
  {
    // Codez Ici
  }

  /**
   * Permet d'afficher la vue permettant de crÃ©er une rÃ©source.
   *
   * @return void
   */
  public function create()
  {
    // Codez Ici
  }

  /**
   * Permet d'ajouter une nouvelle rÃ©source dans la base d'information
   *
   * @return void
   */
  public function store()
  {
    // Codez Ici
  }

  /**
   * Permet de rÃ©cupÃ©rer un information prÃ©cise avec un identifiant.
   *
   * @param mixed $id
   * @return void
   */
  public function show($id)
  {
    // Codez Ici
  }

  /**
   * Mise Ã  jour d'une ressource en utilisant paramÃ¨tre du GET
   *
   * @param mixed $id
   * @return void
   */
  public function edit($id)
  {
    // Codez Ici
  }

  /**
   * Mise Ã  jour d'une rÃ©source
   *
   * @param mixed $id
   * @return void
   */
  public function update($id)
  {
    // Codez Ici
  }

  /**
   * Permet de supprimer une resource
   *
   * @param mixed $id
   * @return void
   */
  public function destroy($id)
  {
    // Codez Ici
  }
}
```

### Utilisons notre contrÃ´leur REST

Pour utiliser le contrÃ´leur Rest, vous avez juste Ã  utiliser la mÃ©thode `rest` sur la variable globale `$app` dans vos fichiers de [routing](./routing).

#### Prototype de la mÃ©thode `rest`

```php
$app->rest(url, action, where = []);
```

| paramete | Type |
|----------|------|
| `url` | `String`, `Array` - Le nom de la route |
| `action` | `String` -  Le nom de la route |
| `where` | `Array` - Contrainte sur la varible `id` |

#### Utilisation simple

Et Ã§a donne ceci :

```php
$app->rest('pets', 'PetController');
```

#### Utilisation avec les contraintes

Avec une contrainte Ã§a donne ceci:

```php
$app->rest('pets', 'PetController', ['id' => '\d+']);
```

Ici la contrainte s'applique sur toutes les mÃ©thodes. Mais, vous avez aussi la possibilitÃ© de restreindre les contraintes sur des mÃ©thodes comme ceci :

```php
$app->rest('pets', 'PetController', [
  'show' => ['id' => '\d+'],
  'edit' => ['id' => '[a-z]+'],
]);
```

#### Utilisation via un tableau comme action

Dans le cas ou `action` est un `array` voici les clÃ©s/valeurs possibles.

```php
$action = [
  'controller' => 'PetController',
  'ignores' => ['index', 'create'],
];

$app->rest('pets', $action, ['id' => '\d+']);
```

#### Ignore des mÃ©thodes

La valeur de `ignores` sear une liste de mÃ©thode/url qui seront ignorÃ©es par le `routeur`. Alors, dans l'exemple prÃ©cÃ©dent les mÃ©thodes `index` et `create` seront indisponibles.

#### Url et Action

En considered la dÃ©finition Rest suivant:

```php
$action = [
  'controller' => 'PetController',
  'ignores' => ['index', 'create'],
];

$app->rest('pets', $action, ['id' => '\d+']);
```

| URL | MÃ©thode HTTP | Nom de la route | Description |
|----------|------|------|------|
| `/pets` | `GET` | `pets.index` | Retourne la liste des pets |
| `/pets` | `POST` | `pets.store` | Permet d'ajouter un autre pet |
| `/pets/:id` | `GET` | `pets.show` | Afficher un seul pet |
| `/pets/:id` | `PUT/PATCH` | `pets.update` | Permet de mettre Ã  jour les informations d'un pet |
| `/pets/:id` | `DELETE` | `pets.delete` | Ceci va supprimer un pet |
| `/pets/create` | `GET` | `pets.create` | Permet d'afficher le formulaire d'ajout |

<SuggestionFeature />
