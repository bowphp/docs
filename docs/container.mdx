---
id: container
title: "üß∞ Conteneur d'injection de d√©pendances"
---

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

# Introduction

### Qu'est-ce que l'Injection de D√©pendances (DI) ?

L'**injection de d√©pendances** est un concept qui permet de **fournir** les objets dont une classe a besoin plut√¥t que de les cr√©er elle-m√™me. Cela permet de rendre le code plus modulaire et plus facile √† tester. Plut√¥t que d'instancier directement des objets dans une classe, vous les **injectez** via son constructeur ou une autre m√©thode.

### Qu'est-ce que l'Inversion de Contr√¥le (IoC) ?

L'**inversion de contr√¥le** est un principe qui consiste √† **d√©l√©guer** la gestion des objets et de leurs d√©pendances √† un autre composant appel√© **conteneur**. Cela signifie que le conteneur cr√©e et g√®re les objets n√©cessaires pour vous, au lieu que votre code les cr√©e manuellement.

Dans BowPHP, cette gestion est faite par un conteneur appel√© **Capsule**.

## Pourquoi utiliser un Conteneur DIC ?

Le conteneur DIC de BowPHP vous permet de g√©rer facilement toutes les d√©pendances de votre application. Voici quelques avantages :

1. **Facilite la gestion des objets** : Plus besoin de cr√©er des objets partout dans votre code.
2. **Modularit√© et r√©utilisabilit√©** : Votre code devient plus facile √† maintenir et √† tester.
3. **Flexibilit√©** : Vous pouvez facilement changer la fa√ßon dont les objets sont cr√©√©s et g√©r√©s.

## Comment utiliser le Conteneur DIC dans BowPHP ?

### 1. **Acc√©der au Conteneur**

Le conteneur est l'endroit o√π toutes les d√©pendances sont stock√©es. Voici comment y acc√©der :

#### Via un helper :
```php
$container = app();  // Retourne l'instance du conteneur
```

#### Via la classe `Capsule` :

```php
use Bow\Container\Capsule;
$container = Capsule::getInstance();  // Acc√®de au conteneur de fa√ßon plus explicite
```

Les deux m√©thodes vous permettent de travailler avec le m√™me conteneur.

### 2. **Enregistrer des Liaisons dans le Conteneur**

Lorsque vous avez une classe ou un service que vous souhaitez utiliser dans plusieurs endroits de votre application, vous devez **enregistrer** cette classe dans le conteneur.

#### Exemple de liaison simple :

Vous voulez dire au conteneur : "Lorsque quelqu'un demandera un service, voici comment le cr√©er" :

```php
use App\Services\Service;
app()->bind('service', function() {
    return new Service();  // Retourne une nouvelle instance du service
});
```

#### Exemple de liaison d'une instance unique (singleton) :

Dans certains cas, vous ne voulez cr√©er qu'une seule instance d'une classe (par exemple, pour la configuration). Vous pouvez utiliser un **singleton** :

```php
app()->instance('config', new Config());  // Une seule instance de Config sera utilis√©e
```

#### Exemple de liaison d'une fabrique :

Si vous voulez que le conteneur cr√©e une nouvelle instance chaque fois qu'une d√©pendance est demand√©e, mais avec un contr√¥le sp√©cifique sur la cr√©ation, vous pouvez utiliser une **fabrique** :

```php
app()->factory('user', function() {
    return new User();  // Cr√©e une nouvelle instance de User √† chaque fois
});
```

### 3. **R√©soudre des D√©pendances**

Une fois qu'un objet est enregistr√© dans le conteneur, vous pouvez facilement le r√©cup√©rer (ou **le r√©soudre**) √† tout moment dans votre application. Le conteneur cr√©e et fournit l'objet pour vous.

#### R√©solution simple :

```php
$service = app()->make('service');  // R√©cup√®re l'objet enregistr√© sous la cl√© 'service'
```

#### R√©solution avec param√®tres :
Si la classe que vous voulez r√©cup√©rer a des **param√®tres** (comme des arguments dans son constructeur), vous pouvez les fournir facilement :

```php
$service = app()->makeWith('service', ['param' => 'value']);  // Passe des param√®tres √† la classe
```

#### Via la fonction helper :
```php
$service = app(Service::class);  // R√©cup√®re l'objet directement en utilisant la classe
```

### 4. **Injection Automatique des D√©pendances**

Si une classe d√©pend d'une autre (par exemple, un service qui utilise un repository), le conteneur peut automatiquement cr√©er les objets n√©cessaires et les injecter. Cela vous √©vite de devoir cr√©er manuellement les objets.

#### Exemple :

Imaginons que vous ayez une classe `UserService` qui a besoin de `UserRepository` :

```php
class UserService
{
    private $repository;
    
    public function __construct(UserRepository $repository)
    {
        $this->repository = $repository;  // Le conteneur injecte UserRepository ici
    }
}
```

Le conteneur peut automatiquement **injecter** `UserRepository` lorsque vous demandez une instance de `UserService` :

```php
$userService = app(UserService::class);  // Le conteneur cr√©e UserService et injecte UserRepository
```

### 5. **Liaisons de Types Simples et Complexes**

#### Liaison simple

Chaque fois que vous demandez l'objet, une **nouvelle instance** est cr√©√©e :

```php
app()->bind('logger', function() {
    return new Logger();  // Cr√©e un nouvel objet Logger chaque fois
});
```

#### Liaison singleton
Une **seule instance** est utilis√©e √† travers toute l'application :
```php
app()->instance('config', new Config());  // Utilise la m√™me instance partout
```

#### Liaison fabrique

Chaque demande g√©n√®re **une nouvelle instance** :

```php
app()->factory('user', function() {
    return new User();  // Cr√©e une nouvelle instance √† chaque fois
});
```

### 6. **V√©rification de l'Existence d'une Liaison**

Avant de r√©soudre une d√©pendance, vous pouvez v√©rifier si le conteneur contient d√©j√† l'objet demand√©.

#### Exemple :

```php
if (isset(app('service'))) {
  // Le service existe dans le conteneur
}
```

## Bonnes Pratiques √† Suivre

1. **Utilisez l'injection par constructeur** : Cela permet de d√©clarer clairement les d√©pendances d'une classe et est facile √† tester.
2. **Privil√©giez les interfaces aux classes concr√®tes** : Utilisez des interfaces pour les d√©pendances afin de garder votre code flexible et facile √† maintenir.
3. **Limitez l'utilisation des singletons** : Les singletons sont utiles pour certaines situations, mais il est pr√©f√©rable de ne pas en abuser, car cela peut rendre le code difficile √† tester.

## Exemple Complet pour D√©butants

Voici un exemple complet pour comprendre comment tout cela fonctionne ensemble :

### D√©finir une Interface

Une interface d√©finit ce que doit faire un service, mais pas comment il le fait :

```php
interface UserRepositoryInterface {
    public function find($id);
}
```

### Impl√©mentation de l'Interface

Une classe qui impl√©mente cette interface fournit l'impl√©mentation r√©elle :

```php
class UserRepository implements UserRepositoryInterface {
    public function find($id) {
        return "Utilisateur avec l'ID : " . $id;
    }
}
```

### Service Utilisant le Repository

`UserService` a besoin de `UserRepository` pour fonctionner :

```php
class UserService {
    private $repository;
    
    public function __construct(UserRepositoryInterface $repository)
    {
        $this->repository = $repository;
    }
    
    public function getUser($id)
    {
        return $this->repository->find($id);
    }
}
```

### Enregistrement dans le Conteneur

Enregistrez l'interface et l'impl√©mentation dans le conteneur :

```php
app()->bind(UserRepositoryInterface::class, UserRepository::class);
```

### Utilisation dans le Code

Le conteneur cr√©e automatiquement le service et ses d√©pendances :

```php
$userService = app(UserService::class);

echo $userService->getUser(1);  // Affiche : "Utilisateur avec l'ID : 1"
```

Le conteneur d'injection de d√©pendances de BowPHP rend votre code plus **modulaire**, **flexible**, et **testable**. En utilisant l'IoC, vous d√©l√©guez la gestion des objets et des d√©pendances √† un conteneur, ce qui simplifie la cr√©ation et l'utilisation des objets dans votre application. Gr√¢ce √† ces principes, vous pouvez cr√©er des applications plus propres, plus faciles √† maintenir et plus robustes.

<SuggestionFeature />
