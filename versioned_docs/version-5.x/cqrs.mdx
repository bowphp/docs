---
id: cqrs
title: "ü§† CQRS"
---

import SuggestionFeature from "@site/src/components/Partials/SuggestionFeature";

## Introduction

**CQRS** (*Command Query Responsibility Segregation*) est un mod√®le d'architecture qui s√©pare les responsabilit√©s des commandes et des requ√™tes. L'id√©e principale est d'utiliser un mod√®le diff√©rent pour les op√©rations d'√©criture (commandes) et de lecture (requ√™tes).

:::info Quand utiliser CQRS ?
Cette approche peut √™tre utile dans des situations complexes, bien que pour la plupart des syst√®mes, **CQRS** puisse introduire une certaine complexit√© suppl√©mentaire. Privil√©giez CQRS pour les syst√®mes o√π les besoins en lecture et en √©criture sont tr√®s diff√©rents.
:::

[Pour plus d'informations sur CQRS, consultez cet article de Martin Fowler](https://www.martinfowler.com/bliki/CQRS.html).

## Installation

Ajoutez le package CQRS √† votre projet avec la commande suivante :

```bash
composer require bowphp/cqrs
```

## Utilisation des commandes (Commands)

Les commandes repr√©sentent des intentions d'effectuer des op√©rations d'√©criture ou des actions qui modifient l'√©tat de votre syst√®me.

### √âtape 1 : Cr√©er une commande

Cr√©ez une commande en impl√©mentant l'interface `Bow\CQRS\Command\CommandInterface`. Par exemple, pour cr√©er un utilisateur :

```php title="app/Commands/CreateUserCommand.php"
use Bow\CQRS\Command\CommandInterface;

class CreateUserCommand implements CommandInterface
{
  public function __construct(
    public string $username,
    public string $email
  ) {}
}
```

### √âtape 2 : Cr√©er un handler pour la commande

Cr√©ez un handler qui ex√©cutera la logique associ√©e √† la commande. Ce handler doit impl√©menter l'interface `Bow\CQRS\Command\CommandHandlerInterface` :

```php {7} title="app/CommandHandlers/CreateUserCommandHandler.php"
use Bow\CQRS\Command\CommandHandlerInterface;

class CreateUserCommandHandler implements CommandHandlerInterface
{
  public function __construct(public UserService $userService) {}

  public function process(CommandInterface $command): mixed
  {
    if ($this->userService->exists($command->email)) {
      throw new UserServiceException(
        "The user already exists"
      );
    }

    return $this->userService->create([
      "username" => $command->username,
      "email" => $command->email
    ]);
  }
}
```

:::tip Bonnes pratiques
Le handler doit contenir la logique m√©tier associ√©e √† la commande. Il est recommand√© d'injecter les d√©pendances (comme les services) via le constructeur.
:::

### √âtape 3 : Enregistrer la commande et son handler

Ajoutez la commande et son handler dans le registre des commandes dans `App\Configurations\ApplicationConfiguration::class` :

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
  CQRSRegistration::commands([
    CreateUserCommand::class => CreateUserCommandHandler::class
  ]);
}
```

### √âtape 4 : Ex√©cuter la commande dans un contr√¥leur

Dans un contr√¥leur, utilisez le `CommandBus` pour ex√©cuter la commande :

```php {3,9,15-18,20} title="app/Controllers/UserController.php"
namespace App\Controllers;

use Bow\CQRS\Command\CommandBus;
use App\Controllers\Controller;
use App\Commands\CreateUserCommand;

class UserController extends Controller
{
  public function __construct(private CommandBus $commandBus) {}

  public function __invoke(Request $request)
  {
    $payload = $request->only(['username', 'email']);

    $command = new CreateUserCommand(
      $payload['username'],
      $payload['email']
    );

    $result = $this->commandBus->execute($command);

    return redirect()
      ->back()
      ->withFlash("message", "User created");
  }
}
```

Ajoutez une route pour appeler cette m√©thode :

```php
$app->post("/users/create", UserController::class);
```

## Utilisation des requ√™tes (Queries)

Les requ√™tes sont utilis√©es pour r√©cup√©rer des donn√©es sans modifier l'√©tat de votre syst√®me. Elles doivent √™tre en lecture seule.

### √âtape 1 : Cr√©er une requ√™te

Cr√©ez une requ√™te en impl√©mentant l'interface `Bow\CQRS\Query\QueryInterface`. Par exemple, pour r√©cup√©rer un utilisateur par son ID :

```php title="app/Queries/GetUserByIdQuery.php"
use Bow\CQRS\Query\QueryInterface;

class GetUserByIdQuery implements QueryInterface
{
  public function __construct(public int $userId) {}
}
```

### √âtape 2 : Cr√©er un handler pour la requ√™te

Cr√©ez un handler pour ex√©cuter la logique de r√©cup√©ration des donn√©es. Ce handler doit impl√©menter l'interface `Bow\CQRS\Query\QueryHandlerInterface` :

```php {7} title="app/QueryHandlers/GetUserByIdQueryHandler.php"
use Bow\CQRS\Query\QueryHandlerInterface;

class GetUserByIdQueryHandler implements QueryHandlerInterface
{
  public function __construct(public UserService $userService) {}

  public function retrieve(QueryInterface $query): mixed
  {
    return $this->userService->findById($query->userId);
  }
}
```

:::note Lecture seule
Les handlers de requ√™te ne doivent jamais modifier l'√©tat du syst√®me. Ils sont exclusivement d√©di√©s √† la r√©cup√©ration de donn√©es.
:::

### √âtape 3 : Enregistrer la requ√™te et son handler

Ajoutez la requ√™te et son handler dans le registre des requ√™tes dans `App\Configurations\ApplicationConfiguration::class` :

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
  CQRSRegistration::queries([
    GetUserByIdQuery::class => GetUserByIdQueryHandler::class
  ]);
}
```

### √âtape 4 : Ex√©cuter la requ√™te dans un contr√¥leur

Dans un contr√¥leur, utilisez le `QueryBus` pour ex√©cuter la requ√™te :

```php {3,9,15-18,20} title="app/Controllers/UserController.php"
namespace App\Controllers;

use Bow\CQRS\Query\QueryBus;
use App\Controllers\Controller;
use App\Queries\GetUserByIdQuery;

class UserController extends Controller
{
  public function __construct(private QueryBus $queryBus) {}

  public function show(int $userId)
  {
    $query = new GetUserByIdQuery($userId);

    $user = $this->queryBus->execute($query);

    return view("user.profile", ["user" => $user]);
  }
}
```

Ajoutez une route pour appeler cette m√©thode :

```php
$app->get("/users/{id}", [UserController::class, 'show']);
```

## Enregistrement avec les attributs PHP

Vous pouvez aussi lier automatiquement les handlers √† leurs commandes/requ√™tes avec des attributs PHP et une seule d√©claration de registre.

```php title="app/CommandHandlers/CreateUserCommandHandler.php"
use Bow\CQRS\Attribute\CommandHandler;
use Bow\CQRS\Command\CommandHandlerInterface;
use Bow\CQRS\Command\CommandInterface;

#[CommandHandler(CreateUserCommand::class)]
class CreateUserCommandHandler implements CommandHandlerInterface
{
  public function __construct(public UserService $userService) {}

  public function process(CommandInterface $command): mixed
  {
    // ...
  }
}
```

```php title="app/QueryHandlers/GetUserByIdQueryHandler.php"
use Bow\CQRS\Attribute\QueryHandler;
use Bow\CQRS\Query\QueryHandlerInterface;
use Bow\CQRS\Query\QueryInterface;

#[QueryHandler(GetUserByIdQuery::class)]
class GetUserByIdQueryHandler implements QueryHandlerInterface
{
  public function __construct(public UserService $userService) {}

  public function process(QueryInterface $query): mixed
  {
    // ...
  }
}
```

Enregistrez ensuite tous les handlers annot√©s en une fois :

```php title="app/Configurations/ApplicationConfiguration.php"
use Bow\CQRS\Registration as CQRSRegistration;

public function run()
{
  CQRSRegistration::handlers([
    CreateUserCommandHandler::class,
    GetUserByIdQueryHandler::class,
  ]);
}
```

## Conclusion

Avec **CQRS**, vous pouvez structurer vos applications pour s√©parer clairement les pr√©occupations entre la lecture et l'√©criture, tout en conservant un code organis√© et maintenable.

:::tip Avantages de CQRS
- **S√©paration des responsabilit√©s** : Les op√©rations de lecture et d'√©criture sont isol√©es
- **Scalabilit√©** : Possibilit√© d'optimiser ind√©pendamment les lectures et les √©critures
- **Maintenabilit√©** : Code plus facile √† tester et √† maintenir
- **Flexibilit√©** : Permet d'utiliser diff√©rents mod√®les de donn√©es pour les lectures et les √©critures
:::


<SuggestionFeature />
